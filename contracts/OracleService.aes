// ISC License
//
// Copyright (c) 2020, aeternity developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.


// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST

@compiler >= 4.2

include "List.aes"

contract OracleService =

  type oracle_type = oracle(string, string)
  type oracle_query_tuples = list(oracle_type * oracle_query(string, string))

  record success_claim =
    { success : bool
    , caller : address
    , percentage : int }

  record state =
    { trusted_oracles : map(int, oracle_type)
    , oracle_queries : map(string, oracle_query_tuples)
    , minimum_amount_of_oracles : int
    , success_claimed_urls : map(string, success_claim)
    , owner : address }

  entrypoint init(minimum_amount_of_oracles : int, owner : address) =
    { trusted_oracles = {},
      oracle_queries = {},
      minimum_amount_of_oracles = minimum_amount_of_oracles,
      success_claimed_urls = {},
      owner = owner }

  stateful entrypoint add_oracle(oracle : oracle_type) =
    require_owner()
    require(Oracle.check(oracle), "ORACLE_CHECK_FAILED")
    put(state{ trusted_oracles[Map.size(state.trusted_oracles)] = oracle })

  stateful entrypoint remove_oracle(id : int) =
    require_owner()
    put(state{ trusted_oracles = Map.delete(id, state.trusted_oracles) })

  entrypoint estimate_query_fee() : int =
    estimate_query_fee_iterate(0, Map.to_list(state.trusted_oracles))

  payable stateful entrypoint query_oracle(url : string) : oracle_query_tuples =
    require(estimate_query_fee() == Call.value, "QUERY_FEE_NOT_MATCHING")
    require_minimum_amount_of_oracles()
    let query_oracle = (o) => switch(o)
      (_, oracle) => (oracle, Oracle.query(oracle, url, Oracle.query_fee(oracle), RelativeTTL(20), RelativeTTL(20)))
    let queries = List.map(query_oracle, Map.to_list(state.trusted_oracles))
    put(state{ oracle_queries = state.oracle_queries{[url] = queries }})
    queries

  stateful entrypoint check_persist_claim(url : string) : success_claim =
    let success_claim = state.success_claimed_urls[url = { success = false, caller = Call.origin, percentage = 0 }]
    if(success_claim.success)
      success_claim
    else
      let checked_claim = check_claim(url)
      put(state{ success_claimed_urls[url] = checked_claim })
      checked_claim

  stateful function check_claim(url : string) : success_claim =
    let oracle_answers = check_oracle_answers(url)
    let answers_length = List.length(oracle_answers)
    let is_positive = (answer) => switch(answer)
      Some(response) => response
      None => false
    let positive_answers_length = List.length(List.filter(is_positive, oracle_answers))
    let percentage = positive_answers_length * 100 / answers_length
    let success = percentage > 50
    if(success) put(state{ oracle_queries = Map.delete(url, state.oracle_queries) }) else ()
    { success = success, caller = Call.origin, percentage = percentage }

  entrypoint check_oracle_answers(url : string) : list(option(bool)) =
    let check_query = (oracle, query) => switch(Oracle.get_answer(oracle, query))
      Some(response) => Some(response == Address.to_str(Call.origin))
      None => None
    [ check_query(oracle, query) | (oracle, query) <- state.oracle_queries[url] ]

  entrypoint get_state() = state

  function
    estimate_query_fee_iterate : (int, list((int * oracle_type))) => int
    estimate_query_fee_iterate(fee_acc, [])      = fee_acc
    estimate_query_fee_iterate(fee_acc, o :: os) = switch(o)
      (_, oracle) => estimate_query_fee_iterate(fee_acc + Oracle.query_fee(oracle), os)

  function require_minimum_amount_of_oracles() =
    require(Map.size(state.trusted_oracles) >= state.minimum_amount_of_oracles, "MORE_ORACLES_REQUIRED")

  function require_owner() =
    require(Call.caller == state.owner, "OWNER_REQUIRED")
