// ISC License
//
// Copyright (c) 2020, aeternity developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.


// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST

@compiler >= 4.2

include "List.aes"

contract OracleService =

  type oracle_query_tuples = list(oracle(string, string) * oracle_query(string, string))

  record state =
    { trusted_oracles : list(oracle(string, string))
    , oracle_queries : map(string, oracle_query_tuples)
    , minimum_amount_of_oracles : int
    , owner : address }

  entrypoint init(minimum_amount_of_oracles : int, owner : address) =
    { trusted_oracles = [],
      oracle_queries = {},
      minimum_amount_of_oracles = minimum_amount_of_oracles,
      owner = owner }

  stateful entrypoint add_oracle(oracle : oracle(string, string)) =
    require_owner()
    require(Oracle.check(oracle), "ORACLE_CHECK_FAILED")
    put(state{ trusted_oracles = oracle :: state.trusted_oracles})

  entrypoint estimate_query_fee() : int =
    List.sum(List.map((oracle) => Oracle.query_fee(oracle), state.trusted_oracles))

  // TODO: adjust ttls
  payable stateful entrypoint query_oracle(url : string) : oracle_query_tuples =
    require_minimum_amount_of_oracles()
    let query_oracle = (oracle) => (oracle, Oracle.query(oracle, url, Oracle.query_fee(oracle), RelativeTTL(10), RelativeTTL(10)))
    let queries = List.map(query_oracle, state.trusted_oracles)
    put(state{ oracle_queries = state.oracle_queries{[url] = queries }})
    queries

  // TODO: persist url as approved, cleanup state
  entrypoint check_claim(url : string) : bool =
    let oracle_answers = check_oracle_answers(url)
    let answers_length = List.length(oracle_answers)
    let is_positive = (answer) => switch(answer)
      Some(response) => response
      None => false
    let positive_answers_length = List.length(List.map(is_positive, oracle_answers))
    let percentage = positive_answers_length * 100 / answers_length
    percentage > 50

  entrypoint check_oracle_answers(url : string) : list(option(bool)) =
    let check_query = (oracle, query) => switch(Oracle.get_answer(oracle, query))
      Some(response) => Some(response == Address.to_str(Call.caller))
      None => None
    [ check_query(oracle, query) | (oracle, query) <- state.oracle_queries[url] ]

  entrypoint get_state() = state

  function require_minimum_amount_of_oracles() =
    require(List.length(state.trusted_oracles) >= state.minimum_amount_of_oracles, "MORE_ORACLES_REQUIRED")

  function require_owner() =
    require(Call.caller == state.owner, "OWNER_REQUIRED")
